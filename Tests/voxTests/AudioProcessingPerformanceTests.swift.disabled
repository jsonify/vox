import XCTest
import Foundation
import AVFoundation
@testable import vox

final class AudioProcessingPerformanceTests: XCTestCase {
    
    var audioProcessor: AudioProcessor!
    var ffmpegProcessor: FFmpegProcessor!
    var testFileGenerator: TestAudioFileGenerator!
    var tempDirectory: URL!
    
    override func setUp() {
        super.setUp()
        audioProcessor = AudioProcessor()
        ffmpegProcessor = FFmpegProcessor()
        testFileGenerator = TestAudioFileGenerator.shared
        tempDirectory = FileManager.default.temporaryDirectory.appendingPathComponent("perf_tests_\(UUID().uuidString)")
        try? FileManager.default.createDirectory(at: tempDirectory, withIntermediateDirectories: true)
    }
    
    override func tearDown() {
        audioProcessor = nil
        ffmpegProcessor = nil
        try? FileManager.default.removeItem(at: tempDirectory)
        testFileGenerator?.cleanup()
        testFileGenerator = nil
        super.tearDown()
    }
    
    // MARK: - AVFoundation Performance Tests
    
    func testAVFoundationSmallFilePerformance() {\n        measureAVFoundationPerformance(\n            testName: \"Small File (1 second)\",\n            createFileBlock: { self.testFileGenerator.createSmallMP4File() },\n            expectedMaxDuration: 5.0\n        )\n    }\n    \n    func testAVFoundationMediumFilePerformance() {\n        measureAVFoundationPerformance(\n            testName: \"Medium File (30 seconds)\",\n            createFileBlock: { self.testFileGenerator.createMockMP4File(duration: 30.0) },\n            expectedMaxDuration: 15.0\n        )\n    }\n    \n    func testAVFoundationLargeFilePerformance() {\n        measureAVFoundationPerformance(\n            testName: \"Large File (5 minutes)\",\n            createFileBlock: { self.testFileGenerator.createLargeMP4File() },\n            expectedMaxDuration: 60.0\n        )\n    }\n    \n    func testAVFoundationHighQualityFilePerformance() {\n        measureAVFoundationPerformance(\n            testName: \"High Quality File\",\n            createFileBlock: { self.testFileGenerator.createHighQualityMP4File() },\n            expectedMaxDuration: 20.0\n        )\n    }\n    \n    private func measureAVFoundationPerformance(\n        testName: String,\n        createFileBlock: () -> URL?,\n        expectedMaxDuration: TimeInterval\n    ) {\n        guard let testVideoURL = createFileBlock() else {\n            XCTFail(\"Failed to create test file for \\(testName)\")\n            return\n        }\n        \n        let expectation = XCTestExpectation(description: \"AVFoundation performance: \\(testName)\")\n        let startTime = Date()\n        var processingMetrics: ProcessingMetrics?\n        \n        audioProcessor.extractAudio(\n            from: testVideoURL.path,\n            progressCallback: { progress in\n                // Track progress timing\n                if progress.currentProgress == 1.0 {\n                    let endTime = Date()\n                    let totalTime = endTime.timeIntervalSince(startTime)\n                    \n                    processingMetrics = ProcessingMetrics(\n                        totalTime: totalTime,\n                        processingSpeed: progress.processingSpeed,\n                        startTime: startTime,\n                        endTime: endTime\n                    )\n                }\n            }\n        ) { result in\n            switch result {\n            case .success(let audioFile):\n                let endTime = Date()\n                let totalTime = endTime.timeIntervalSince(startTime)\n                \n                // Performance assertions\n                XCTAssertLessThan(totalTime, expectedMaxDuration, \n                                \"\\(testName) processing took \\(totalTime)s, expected < \\(expectedMaxDuration)s\")\n                \n                // Verify processing speed if available\n                if let metrics = processingMetrics {\n                    XCTAssertEqual(metrics.totalTime, totalTime, accuracy: 0.1)\n                    \n                    if let speed = metrics.processingSpeed {\n                        XCTAssertGreaterThan(speed, 0, \"Processing speed should be positive\")\n                    }\n                }\n                \n                // Verify output quality metrics\n                let format = audioFile.format\n                XCTAssertGreaterThan(format.duration, 0, \"Output should have valid duration\")\n                XCTAssertTrue(format.isValid, \"Output format should be valid\")\n                \n                // Calculate processing ratio (processing time / audio duration)\n                let processingRatio = totalTime / format.duration\n                XCTAssertLessThan(processingRatio, 2.0, \n                                \"Processing should be faster than 2x real-time for \\(testName)\")\n                \n                print(\"\\(testName) Performance:\")\n                print(\"  Processing Time: \\(String(format: \"%.2f\", totalTime))s\")\n                print(\"  Audio Duration: \\(String(format: \"%.2f\", format.duration))s\")\n                print(\"  Processing Ratio: \\(String(format: \"%.2f\", processingRatio))x\")\n                print(\"  Sample Rate: \\(format.sampleRate) Hz\")\n                print(\"  Channels: \\(format.channels)\")\n                if let bitRate = format.bitRate {\n                    print(\"  Bit Rate: \\(bitRate) bps\")\n                }\n                \n            case .failure(let error):\n                XCTFail(\"\\(testName) processing failed: \\(error)\")\n            }\n            \n            expectation.fulfill()\n        }\n        \n        wait(for: [expectation], timeout: expectedMaxDuration + 10.0)\n    }\n    \n    // MARK: - FFmpeg Performance Tests\n    \n    func testFFmpegSmallFilePerformance() {\n        guard FFmpegProcessor.isFFmpegAvailable() else {\n            throw XCTSkip(\"FFmpeg not available for performance testing\")\n        }\n        \n        measureFFmpegPerformance(\n            testName: \"FFmpeg Small File (1 second)\",\n            createFileBlock: { self.testFileGenerator.createSmallMP4File() },\n            expectedMaxDuration: 10.0\n        )\n    }\n    \n    func testFFmpegMediumFilePerformance() {\n        guard FFmpegProcessor.isFFmpegAvailable() else {\n            throw XCTSkip(\"FFmpeg not available for performance testing\")\n        }\n        \n        measureFFmpegPerformance(\n            testName: \"FFmpeg Medium File (30 seconds)\",\n            createFileBlock: { self.testFileGenerator.createMockMP4File(duration: 30.0) },\n            expectedMaxDuration: 30.0\n        )\n    }\n    \n    func testFFmpegHighQualityFilePerformance() {\n        guard FFmpegProcessor.isFFmpegAvailable() else {\n            throw XCTSkip(\"FFmpeg not available for performance testing\")\n        }\n        \n        measureFFmpegPerformance(\n            testName: \"FFmpeg High Quality File\",\n            createFileBlock: { self.testFileGenerator.createHighQualityMP4File() },\n            expectedMaxDuration: 25.0\n        )\n    }\n    \n    private func measureFFmpegPerformance(\n        testName: String,\n        createFileBlock: () -> URL?,\n        expectedMaxDuration: TimeInterval\n    ) {\n        guard let testVideoURL = createFileBlock() else {\n            XCTFail(\"Failed to create test file for \\(testName)\")\n            return\n        }\n        \n        let expectation = XCTestExpectation(description: \"FFmpeg performance: \\(testName)\")\n        let startTime = Date()\n        var progressUpdates: [Double] = []\n        \n        ffmpegProcessor.extractAudio(\n            from: testVideoURL.path,\n            progressCallback: { progress in\n                progressUpdates.append(progress.currentProgress)\n            }\n        ) { result in\n            switch result {\n            case .success(let audioFile):\n                let endTime = Date()\n                let totalTime = endTime.timeIntervalSince(startTime)\n                \n                // Performance assertions\n                XCTAssertLessThan(totalTime, expectedMaxDuration, \n                                \"\\(testName) processing took \\(totalTime)s, expected < \\(expectedMaxDuration)s\")\n                \n                // Verify output quality\n                let format = audioFile.format\n                XCTAssertGreaterThan(format.duration, 0, \"Output should have valid duration\")\n                \n                // Calculate processing efficiency\n                let processingRatio = totalTime / format.duration\n                XCTAssertLessThan(processingRatio, 3.0, \n                                \"FFmpeg processing should be faster than 3x real-time for \\(testName)\")\n                \n                // Analyze progress reporting efficiency\n                XCTAssertGreaterThan(progressUpdates.count, 0, \"Should have progress updates\")\n                \n                print(\"\\(testName) Performance:\")\n                print(\"  Processing Time: \\(String(format: \"%.2f\", totalTime))s\")\n                print(\"  Audio Duration: \\(String(format: \"%.2f\", format.duration))s\")\n                print(\"  Processing Ratio: \\(String(format: \"%.2f\", processingRatio))x\")\n                print(\"  Progress Updates: \\(progressUpdates.count)\")\n                print(\"  Sample Rate: \\(format.sampleRate) Hz\")\n                print(\"  Channels: \\(format.channels)\")\n                \n            case .failure(let error):\n                XCTFail(\"\\(testName) processing failed: \\(error)\")\n            }\n            \n            expectation.fulfill()\n        }\n        \n        wait(for: [expectation], timeout: expectedMaxDuration + 15.0)\n    }\n    \n    // MARK: - Comparative Performance Tests\n    \n    func testAVFoundationVsFFmpegPerformance() {\n        guard FFmpegProcessor.isFFmpegAvailable() else {\n            throw XCTSkip(\"FFmpeg not available for comparative testing\")\n        }\n        \n        guard let testVideoURL = self.testFileGenerator.createMockMP4File(duration: 10.0) else {\n            XCTFail(\"Failed to create test file\")\n            return\n        }\n        \n        var avFoundationTime: TimeInterval = 0\n        var ffmpegTime: TimeInterval = 0\n        \n        // Test AVFoundation performance\n        let avExpectation = XCTestExpectation(description: \"AVFoundation comparative test\")\n        let avStartTime = Date()\n        \n        audioProcessor.extractAudio(from: testVideoURL.path) { result in\n            avFoundationTime = Date().timeIntervalSince(avStartTime)\n            \n            switch result {\n            case .success:\n                break // Success expected\n            case .failure(let error):\n                XCTFail(\"AVFoundation should succeed: \\(error)\")\n            }\n            \n            avExpectation.fulfill()\n        }\n        \n        wait(for: [avExpectation], timeout: 30.0)\n        \n        // Test FFmpeg performance\n        let ffmpegExpectation = XCTestExpectation(description: \"FFmpeg comparative test\")\n        let ffmpegStartTime = Date()\n        \n        ffmpegProcessor.extractAudio(from: testVideoURL.path) { result in\n            ffmpegTime = Date().timeIntervalSince(ffmpegStartTime)\n            \n            switch result {\n            case .success:\n                break // Success expected\n            case .failure(let error):\n                XCTFail(\"FFmpeg should succeed: \\(error)\")\n            }\n            \n            ffmpegExpectation.fulfill()\n        }\n        \n        wait(for: [ffmpegExpectation], timeout: 30.0)\n        \n        // Compare results\n        print(\"Comparative Performance Results:\")\n        print(\"  AVFoundation: \\(String(format: \"%.2f\", avFoundationTime))s\")\n        print(\"  FFmpeg: \\(String(format: \"%.2f\", ffmpegTime))s\")\n        \n        let ratio = ffmpegTime / avFoundationTime\n        print(\"  FFmpeg/AVFoundation Ratio: \\(String(format: \"%.2f\", ratio))x\")\n        \n        // Both should complete in reasonable time\n        XCTAssertLessThan(avFoundationTime, 20.0, \"AVFoundation should complete quickly\")\n        XCTAssertLessThan(ffmpegTime, 30.0, \"FFmpeg should complete in reasonable time\")\n    }\n    \n    // MARK: - Memory Performance Tests\n    \n    func testMemoryUsageDuringProcessing() {\n        guard let testVideoURL = self.testFileGenerator.createMockMP4File(duration: 30.0) else {\n            XCTFail(\"Failed to create test file\")\n            return\n        }\n        \n        let expectation = XCTestExpectation(description: \"Memory usage test\")\n        let memoryTracker = MemoryTracker()\n        \n        memoryTracker.startTracking()\n        \n        audioProcessor.extractAudio(\n            from: testVideoURL.path,\n            progressCallback: { progress in\n                memoryTracker.recordUsage(at: progress.currentProgress)\n            }\n        ) { result in\n            memoryTracker.stopTracking()\n            \n            switch result {\n            case .success:\n                let memoryStats = memoryTracker.getStatistics()\n                \n                print(\"Memory Usage Statistics:\")\n                print(\"  Peak Usage: \\(String(format: \"%.2f\", memoryStats.peakUsage / 1024 / 1024)) MB\")\n                print(\"  Average Usage: \\(String(format: \"%.2f\", memoryStats.averageUsage / 1024 / 1024)) MB\")\n                print(\"  Usage Growth: \\(String(format: \"%.2f\", memoryStats.usageGrowth / 1024 / 1024)) MB\")\n                \n                // Memory usage should be reasonable\n                XCTAssertLessThan(memoryStats.peakUsage, 1024 * 1024 * 1024, \"Peak usage should be < 1GB\")\n                XCTAssertLessThan(memoryStats.usageGrowth, 512 * 1024 * 1024, \"Memory growth should be < 512MB\")\n                \n            case .failure(let error):\n                XCTFail(\"Processing should succeed: \\(error)\")\n            }\n            \n            expectation.fulfill()\n        }\n        \n        wait(for: [expectation], timeout: 45.0)\n    }\n    \n    // MARK: - Concurrent Performance Tests\n    \n    func testConcurrentProcessingPerformance() {\n        let testFiles = (0..<3).compactMap { _ in\n            self.testFileGenerator.createSmallMP4File()\n        }\n        \n        guard testFiles.count == 3 else {\n            XCTFail(\"Failed to create test files\")\n            return\n        }\n        \n        let startTime = Date()\n        let group = DispatchGroup()\n        var completionTimes: [TimeInterval] = []\n        let timesLock = NSLock()\n        \n        // Process files concurrently\n        for testFile in testFiles {\n            group.enter()\n            let individualProcessor = AudioProcessor()\n            let individualStartTime = Date()\n            \n            individualProcessor.extractAudio(from: testFile.path) { result in\n                let individualTime = Date().timeIntervalSince(individualStartTime)\n                \n                timesLock.lock()\n                completionTimes.append(individualTime)\n                timesLock.unlock()\n                \n                switch result {\n                case .success:\n                    break // Expected\n                case .failure(let error):\n                    XCTFail(\"Concurrent processing should succeed: \\(error)\")\n                }\n                \n                group.leave()\n            }\n        }\n        \n        let expectation = XCTestExpectation(description: \"Concurrent processing performance\")\n        group.notify(queue: .main) {\n            expectation.fulfill()\n        }\n        \n        wait(for: [expectation], timeout: 60.0)\n        \n        let totalTime = Date().timeIntervalSince(startTime)\n        let averageIndividualTime = completionTimes.reduce(0, +) / Double(completionTimes.count)\n        \n        print(\"Concurrent Processing Performance:\")\n        print(\"  Total Concurrent Time: \\(String(format: \"%.2f\", totalTime))s\")\n        print(\"  Average Individual Time: \\(String(format: \"%.2f\", averageIndividualTime))s\")\n        print(\"  Concurrency Efficiency: \\(String(format: \"%.1f\", (averageIndividualTime * Double(testFiles.count)) / totalTime))x\")\n        \n        // Concurrent processing should show some efficiency gain\n        XCTAssertLessThan(totalTime, averageIndividualTime * Double(testFiles.count) * 0.8, \n                         \"Concurrent processing should be more efficient than sequential\")\n    }\n    \n    // MARK: - Startup Performance Tests\n    \n    func testProcessorInstantiationPerformance() {\n        measure {\n            for _ in 0..<100 {\n                let _ = AudioProcessor()\n                let _ = FFmpegProcessor()\n            }\n        }\n    }\n    \n    func testTemporaryFileCreationPerformance() {\n        measure {\n            var tempURLs: [URL] = []\n            \n            for _ in 0..<100 {\n                if let tempURL = TempFileManager.shared.createTemporaryAudioFile() {\n                    tempURLs.append(tempURL)\n                }\n            }\n            \n            // Cleanup\n            _ = TempFileManager.shared.cleanupFiles(at: tempURLs)\n        }\n    }\n}\n\n// MARK: - Supporting Classes\n\nstruct ProcessingMetrics {\n    let totalTime: TimeInterval\n    let processingSpeed: Double?\n    let startTime: Date\n    let endTime: Date\n}\n\nstruct MemoryStatistics {\n    let peakUsage: UInt64\n    let averageUsage: UInt64\n    let usageGrowth: UInt64\n    let measurements: Int\n}\n\nclass MemoryTracker {\n    private var measurements: [(progress: Double, usage: UInt64)] = []\n    private var isTracking = false\n    private let measurementQueue = DispatchQueue(label: \"memory.tracker\")\n    \n    func startTracking() {\n        measurementQueue.async {\n            self.isTracking = true\n            self.measurements.removeAll()\n            self.recordInitialUsage()\n        }\n    }\n    \n    func stopTracking() {\n        measurementQueue.async {\n            self.isTracking = false\n        }\n    }\n    \n    func recordUsage(at progress: Double) {\n        guard isTracking else { return }\n        \n        measurementQueue.async {\n            let usage = self.getCurrentMemoryUsage()\n            self.measurements.append((progress: progress, usage: usage))\n        }\n    }\n    \n    func getStatistics() -> MemoryStatistics {\n        return measurementQueue.sync {\n            guard !measurements.isEmpty else {\n                return MemoryStatistics(peakUsage: 0, averageUsage: 0, usageGrowth: 0, measurements: 0)\n            }\n            \n            let usages = measurements.map { $0.usage }\n            let peakUsage = usages.max() ?? 0\n            let averageUsage = usages.reduce(0, +) / UInt64(usages.count)\n            let usageGrowth = peakUsage - (usages.first ?? 0)\n            \n            return MemoryStatistics(\n                peakUsage: peakUsage,\n                averageUsage: averageUsage,\n                usageGrowth: usageGrowth,\n                measurements: measurements.count\n            )\n        }\n    }\n    \n    private func recordInitialUsage() {\n        let usage = getCurrentMemoryUsage()\n        measurements.append((progress: 0.0, usage: usage))\n    }\n    \n    private func getCurrentMemoryUsage() -> UInt64 {\n        var info = mach_task_basic_info()\n        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4\n        \n        let result = withUnsafeMutablePointer(to: &info) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)\n            }\n        }\n        \n        return result == KERN_SUCCESS ? info.resident_size : 0\n    }\n}"}